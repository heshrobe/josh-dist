;;; -*- Mode: LISP; Syntax: Common-Lisp; Base: 10; Package: IDEAL-EDIT -*-(in-package "IDEAL-EDIT");;;;********************************************************;;;;  Copyright (c) 1989, 1992 Rockwell International -- All rights reserved.;;;;  Rockwell International Science Center Palo Alto Lab;;;;********************************************************;;;----------------;;;   ooooooo          PRESENTATION METHODS -- GRAPHICS;;;   ooooooo                  FOR MAIN DISPLAY;;;----------------;;;;;;----------------;;;   ooooooo              PRESENTATION OF NODES;;;----------------;;;;;; draw-self is the top level drawing routine; it both creates;;; a presentation and draws it on the screen.;;; The node is drawn in three pieces so that they may be;;; redisplayed independently (which is what happens when;;; 'redraw-self' is called)(defmethod draw-self ((node graph-node))   (with-slots (display-record) node     (let ((stream (display)))       (setf display-record	     (updating-output (stream)		(with-output-as-presentation		    (stream node (type-of node)			    :single-box t)		  (with-drawing-options (stream					 :transformation (display-xform))		    (draw-body node stream)		    (draw-name node stream)		    (draw-vals node stream))))))));; remove the node entirely from the screen(defmethod undraw-self ((node graph-node))   (with-slots (display-record) node     (when display-record       (erase-output-record display-record (display)))     (setf display-record nil)));; redraw any changed parts of the node(defmethod redraw-self ((node graph-node))  (with-slots (display-record) node    (when display-record      (redisplay display-record (display)))));;; -----------;;; draw the name(defmethod draw-name ((node graph-node) stream)  (with-slots (name center-x center-y) node    (updating-output (stream :cache-value name)      (draw-text* stream 		  (symbol-name name)		  center-x (- center-y 22) :align-x :center))));;; -----------;;; draw the body; this method just sets graphical options,;;; and then calls the specific drawing routine for the node type;;; It is understood that draw-node-icon confines itself to a;;; 40x40 region about the center for all types(defmethod draw-body ((node graph-node) stream)  (with-slots (center-x center-y) node    (let ((line-width (if (evidence-type node) 5 2))	  (color (case (evidence-type node)		   ((nil) (elt *edit-node-colors* 1))		   ((concrete) (elt *edit-node-colors* 0))		   ((virtual) (elt *edit-node-colors* 2)))))      (updating-output (stream :cache-value color)        (with-drawing-options 	    (stream :line-thickness line-width :ink color)	  (draw-node-icon node stream))))));;; the individual node-type graphics(defmethod draw-node-icon ((node probability-node) stream)  (with-slots (center-x center-y selected) node    (draw-circle* stream center-x center-y 19		  :filled selected)))(defmethod draw-node-icon ((node noisy-or-node) stream)  (with-slots (center-x center-y selected) node    (draw-circle* stream center-x center-y 19		  :filled selected)    (draw-line* stream		center-x (+ center-y 19)		(+ center-x 24) (- center-y 8))    (draw-line* stream		center-x (+ center-y 19)		(- center-x 24) (- center-y 8))))(defmethod draw-node-icon ((node decision-node) stream)  (with-slots (center-x center-y selected) node    (draw-rectangle* stream 		     (- center-x 17) (- center-y 17)		     (+ center-x 17) (+ center-y 17)		     :filled selected)))(defmethod draw-node-icon ((node value-node) stream)  (with-slots (center-x center-y selected) node    (draw-polygon* stream		   (list center-x (- center-y 20)			 (- center-x 20) center-y			 center-x (+ center-y 20)			 (+ center-x 20) center-y)		   :closed t		   :filled selected)))(defmethod draw-node-icon ((node deterministic-node) stream)  (with-slots (center-x center-y selected) node    (draw-ellipse* stream center-x center-y 0 12 20 0		  :filled selected)    (draw-ellipse* stream center-x center-y 0 17 25 0		  :filled selected)));;; ------------;;; draw the bottom values line;;;; this is a showing option:  we only draw;;; anything if the option is on.(create-showing-option   'display-values				; name  t						; init-val  #'(lambda (val) (not val))			; toggle-val  #'(lambda (old-val new-val)			; set-val      (declare (ignore old-val new-val))      (mapc #'redraw-self (slot-value (get-graph-editor) 'node-list)))  #'(lambda (val)				; re-display      (declare (ignore val))      nil)  )(defmethod draw-vals ((node graph-node) stream)  (with-slots (center-x center-y) node    (updating-output (stream		      :cache-value (and (get-showing-option 'display-values)					(solution-generation)))      (draw-text* stream (if (get-showing-option 'display-values)			     (belief-string node)			     "")	          center-x (+ center-y 22)		  :align-x :center :align-y :top		  #- GENERA :text-family #- GENERA :sans-serif		  #- GENERA :text-size #- GENERA :tiny))));;; what to draw, for various node-types(defmethod belief-string ((node graph-node)) (values ""))(defmethod belief-string ((node probability-node))  (if (belief-exists node)      (list-to-string (mapcar #'(lambda (i) (belief-val node i))	                      (slot-value node 'states))		      #'(lambda (x)			  (princ-to-string 			   (if (numberp x) (round (* x 100)) x))))      ""))(defmethod belief-string ((node value-node))  (with-slots (solved-value) node    (if solved-value	(princ-to-string solved-value)	"")))(defmethod belief-string ((node decision-node))  (with-slots (solved-node) node    (if (and solved-node	     (eq 1 (length (ideal:distribution-repn solved-node))))	(princ-to-string 	  (cdr (aref (ideal:distribution-repn solved-node) 0)))	"")));;;--------------;;; Selection;;;--------------(defmethod select-it ((obj selectable-thing))  (with-slots (selected) obj    (when (not selected)      (clear-connects)      (setf selected t)      (undraw-self obj)      (draw-self obj))))(defmethod deselect ((obj selectable-thing))   (with-slots (selected) obj    (when selected      (undraw-self obj)      (setf selected nil)      (draw-self obj))))(defmethod selected-p ((obj selectable-thing))  (with-slots (selected) obj    selected));;;----------------;;;   ooooooo              PRESENTATION OF LINKS;;;----------------(defmethod draw-self ((link link))   (with-slots (display-record from-node to-node vertex-list selected) link     (let ((stream (display)))       (setf display-record	     (updating-output (stream)		(with-output-as-presentation		    (stream link 'link :single-box nil)		  (with-drawing-options (stream					 :transformation (display-xform))    		    (updating-output (stream :cache-value nil)		      (setf vertex-list		        (ie-draw-arrow from-node to-node				    (if selected 2 1)				    stream)))		    (draw-messages link stream))))))))(defmethod undraw-self ((link link))  (with-slots (display-record) link    (when display-record      (erase-output-record display-record (display)))    (setf display-record nil)));; redraw any changed parts of the node(defmethod redraw-self ((link link))  (with-slots (display-record) link    (when display-record      (redisplay display-record (display)))));;; -------------;;; draw the pi or lambda messages.;;; this is another showing option(create-showing-option  'link-messages                ; name nil                           ; init-val #'(lambda (val) (not val))    ; toggle-val #'(lambda (old-val new-val)   ; set-val     (declare (ignore old-val new-val))     (mapc #'redraw-self (slot-value (get-graph-editor) 'link-list))) #'(lambda (val) (declare (ignore val)) nil); re-display)(defmethod draw-messages ((link link) stream)  (with-slots (from-node to-node vertex-list) link    (updating-output (stream		      :cache-value (and (get-showing-option 'link-messages)					(solution-generation)))      (if (get-showing-option 'link-messages)          (let ((fromx (first vertex-list))	        (fromy (second vertex-list))	        (tox (third vertex-list))	        (toy (fourth vertex-list))		(xalign nil)		(yalign nil))	    ;; pi messages	    (if (<= fromx tox) (incf fromx 10) (decf fromx 10))	    (if (<= fromx tox) (setf xalign :left) (setf xalign :right))	    (if (<= fromy toy) (incf fromy 10) (decf fromy 10))	    (if (<= fromy toy) (setf yalign :top) (setf yalign :bottom))	    (draw-text* stream			(pi-message-string from-node to-node)			fromx fromy :align-x xalign :align-y yalign			;:text-family :san-serif			:text-size :tiny)	    ;; lambda messages	    (if (<= tox fromx) (incf tox 10) (decf tox 10))	    (if (<= tox fromx) (setf xalign :left) (setf xalign :right))	    (if (<= toy fromy) (incf toy 10) (decf toy 10))	    (if (<= toy fromy) (setf yalign :top) (setf yalign :bottom))	    (draw-text* stream			(lambda-message-string from-node to-node)			tox toy :align-x xalign :align-y yalign			;:text-family :san-serif			:text-size :tiny))	  ;; else: do something innocuous to make updating-output happy	  (draw-point* stream (first vertex-list) (second vertex-list))))))				      (defun pi-message-string (from-node to-node)  (let ((ideal-from-node (slot-value from-node 'ideal-node))        (ideal-to-node (slot-value to-node 'ideal-node))	(states (slot-value from-node 'states)))    (format nil "P:~a"      (if (assoc ideal-to-node (ideal::node-pi-msg ideal-from-node))	  (list-to-string	   (mapcar #'(lambda (y)	              (ideal::pi-msg-of ideal-to-node					(node-case from-node y)))		   states)	   #'(lambda (pm)	      (if (floatp pm) (format nil "~,2f" pm)	                      (princ-to-string pm))))))))(defun lambda-message-string (from-node to-node)  (let ((ideal-from-node (slot-value from-node 'ideal-node))        (ideal-to-node (slot-value to-node 'ideal-node))	(states (slot-value from-node 'states)))    (format nil "L:~a"      (if (assoc ideal-from-node (ideal::node-lambda-msg ideal-to-node))	  (list-to-string	   (mapcar #'(lambda (y)	              (ideal::lambda-msg-of (node-case from-node y)					    ideal-to-node))		   states)	   #'(lambda (lm)	      (if (floatp lm) (format nil "~,2f" lm)	                      (princ-to-string lm))))))));;; -------------(defun ie-draw-arrow (from to thickness stream)  (let* ((from-x (slot-value from 'center-x))	 (from-y (slot-value from 'center-y))	 (to-x (slot-value to 'center-x))	 (to-y (slot-value to 'center-y))	 (from-box (display-box from))	 (to-box (display-box to)))      ;; determine the truncated line segment which goes from      ;; the center of 'from' to the center of 'to', but which      ;; does not intersect their presentations (if they have any)    (when from-box      (multiple-value-setq (from-x from-y)	(truncate-line* to-x to-y from-x from-y			(bounding-rectangle from-box))))    (when to-box      (multiple-value-setq (to-x to-y)	(truncate-line* from-x from-y to-x to-y			(bounding-rectangle to-box))))    (draw-line* stream from-x from-y to-x to-y :line-thickness thickness)    (draw-arrow-head* stream from-x from-y to-x to-y 10)    (list from-x from-y to-x to-y)));;; -------------(defun draw-arrow-head* (stream x1 y1 x2 y2 len)  (let* ((xdiff (- x1 x2))	 (ydiff (- y1 y2))	 (angle (if (and (zerop xdiff)(zerop ydiff)) 0 (atan ydiff xdiff)))	 (xform (make-rotation-transformation* angle x2 y2))	 (dlen  (/ len 3)))    (draw-polygon* stream		   (list (+ x2 len) (- y2 dlen)			 x2 y2			 (+ x2 len) (+ y2 dlen))		   :transformation xform)))    ;;; -------------;;; return the x and y values of the new endpoint for a;;; line from p1 to p2, stopping at the edge of box.;;;;;; you would think CLIM would provide methods for doing some;;; common things like this, they don't (well, ok, they do, but;;; the result is a #<clim-utils::standard-region-difference>,;;; which you can't do much of anything with).(defun truncate-line* (x1 y1 x2 y2 box)  (let ((dx (- x2 x1))	(dy (- y2 y1))	(tt  0.0)	(temp-t nil))    ;; represent line parametrically as p1 + tt(p2 - p1)    ;; look at each edge of box, and see at what value of    ;; tt it intersects -- the largest tt that is less    ;; than 1.0 wins.    ;; (note this would work wrong if p2 was not     ;; inside the box.)    (when (/= dx 0)      (setf temp-t (/ (- (rectangle-min-x box) x1) dx))      (when (< temp-t 1.0) (setf tt (max tt temp-t)))             (setf temp-t (/ (- (rectangle-max-x box) x1) dx))      (when (< temp-t 1.0) (setf tt (max tt temp-t))))    (when (/= dy 0)      (setf temp-t (/ (- (rectangle-min-y box) y1) dy))      (when (< temp-t 1.0) (setf tt (max tt temp-t)))      (setf temp-t (/ (- (rectangle-max-y box) y1) dy))      (when (< temp-t 1.0) (setf tt (max tt temp-t))))    (values (+ x1 (* tt dx)) (+ y1 (* tt dy)))));;;----------------;;;   ooooooo            WINDOW OPERATIONS;;;----------------;;;;;; Low level graphics methods for the display window.;;; We keep our own coordinate system (established with;;; display-xform) -- all the methods in this section take;;; and/or return coordinates in this system.  (One of the;;; reasons for having some of these methods is that CLIM;;; operates on windows with device coordinates.);;;----------------(defmethod display-box ((frame graph-editor))  "return the bounding box rectangle of the display window"  (bounding-rectangle    (untransform-region (display-xform)		       (window-viewport (display)))))(defmethod display-box ((node graph-node))  "return the bounding box rectangle of the presentation   of this node, if it has one"  (with-slots (display-record) node     (if display-record      (bounding-rectangle        (untransform-region (display-xform)                           display-record))      nil)))(defmethod display-center* (thing)  "return the x and y coordinates of the center of the argument,   which must respond to the display-box method"  (let ((box (display-box thing)))    (values (/ (+ (rectangle-min-x box) (rectangle-max-x box)) 2.0)	    (/ (+ (rectangle-min-y box) (rectangle-max-y box)) 2.0))));;;----------------(defun transform-display (new-xform)  (with-slots (transform) (get-graph-editor)    (setf transform	  (compose-transformations transform new-xform))))(defun scale-display (scale)  "scale the display, leaving the center in place"  (let ((frame (get-graph-editor)))    (multiple-value-bind (old-center-x old-center-y)	(display-center* frame)      (transform-display       (make-scaling-transformation* scale scale				     old-center-x old-center-y)))));;;----------------(defun list-to-string (lst print-fn)  (cond ((null lst) "")	((null (cdr lst))	 (funcall print-fn (car lst)))	(t	 (concatenate 'string		      (funcall print-fn (car lst))		      "/"		      (list-to-string (cdr lst) print-fn)))))