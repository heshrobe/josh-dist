;;; -*- Mode: LISP; Syntax: Common-Lisp; Base: 10; Package: IDEAL-EDIT -*-(in-package "IDEAL-EDIT");;;;********************************************************;;;;  Copyright (c) 1989, 1992 Rockwell International -- All rights reserved.;;;;  Rockwell International Science Center Palo Alto Lab;;;;********************************************************;;;----------------;;;   ooooooo          COMMAND INTERFACE FOR GRAPH EDITOR;;;----------------;;;----------------;;;   ooooooo                   MENU COMMANDS;;;----------------;;;; FUNCTIONS FIRST;;;----------------;;;   ooooooo              GENERAL EDITOR METHODS;;;----------------;;;;;; for some of these methods, the graph editor is implicit --;;; it is retreived from *application-frame*#+lucid(import 'lcl::handler-case 'user)(defun set-new-diagram (new-diagram)  (let ((frame (get-graph-editor)))    (with-slots (ideal-diagram) frame      (setf ideal-diagram new-diagram)      (redisplay-diagram new-diagram frame)      (redraw-display))));;;;; Code to resynchronize DISPLAY with the IDEAL-DIAGRAM for use;;;;; with the id operations (removal and reversal)(defun redisplay-diagram (new-diagram frame)  (with-slots (node-list link-list) frame    (dolist (edit-node (copy-list node-list))      (when (not (ideal:find-node (slot-value edit-node 'name) new-diagram nil))	(setf node-list (delete edit-node node-list))	(close-node-editor edit-node)	(with-unchanged-position ((display))	  (undraw-self edit-node))))	;;; redo all the links    (setf link-list nil)    (dolist (ideal-node new-diagram)      (dolist (parent (ideal:node-predecessors ideal-node))	(push	  (make-instance 'link			 :from (find-node-named (ideal:node-name parent))			 :to (find-node-named (ideal:node-name ideal-node)))	  link-list)))));;;----------------(defun connect-nodes (frame cur-begin-node cur-end-node)  (with-slots (link-list ideal-diagram) frame    (unless (and cur-begin-node cur-end-node)      (error "Bug: link has no endpoint"))    ;; ideal doesn't check for duplicate edges?    (when (some #'(lambda (l)		    (and (is-connected-to l cur-begin-node)			 (is-connected-to l cur-end-node)))		link-list)      (error "There is already a link from ~a to ~a"	     cur-begin-node cur-end-node))    (when (ideal:descendant-p (slot-value cur-end-node 'ideal-node)			      (slot-value cur-begin-node 'ideal-node))      (error "Adding a link from ~a to ~a will create a cycle."	     cur-begin-node cur-end-node))    (let ((new-link (make-instance 'link :from cur-begin-node				   :to cur-end-node))	  #+(or lucid mcl) new-ideal-diagram #+(or lucid mcl) hold)      (handler-case #-(or lucid mcl) (ideal-init new-link ideal-diagram)		    #+(or lucid mcl) (setq new-ideal-diagram (ideal-init new-link ideal-diagram))	 (simple-error (c)		       #+(or lucid mcl) (setq hold t)		       (beep-message "~a" c))		    	 #-(or lucid mcl)	 (:no-error (new-ideal-diagram)		    (setf ideal-diagram new-ideal-diagram)		    (structure-changed)		    (push new-link link-list)		    (draw-self new-link)))      #+(or lucid mcl) (unless hold 		(setf ideal-diagram new-ideal-diagram)		(structure-changed)		(push new-link link-list)		(draw-self new-link))      )))(defun reverse-link (link)  (with-slots (ideal-diagram) *application-frame*    (let (#+(or lucid mcl) hold #+(or lucid mcl) new-diagram)	            (when link	(with-slots (from-node to-node) link		    (handler-case #-(or lucid mcl) (ideal:reverse-arc					   (slot-value from-node 'ideal-node)					   (slot-value to-node 'ideal-node)					   ideal-diagram)				  #+(or lucid mcl) (setq new-diagram						(ideal:reverse-arc						 (slot-value from-node 'ideal-node)						 (slot-value to-node 'ideal-node)						 ideal-diagram))				  (simple-error (c)						#+(or lucid mcl) (setq hold t)						(beep-message "~a" c))				  #-(or lucid mcl)				  (:no-error (new-diagram)					     (set-new-diagram new-diagram)))		    #+(or lucid mcl) (unless hold (set-new-diagram new-diagram))		    )))))(defun delete-link (link)  (with-slots (link-list ideal-diagram) *application-frame*    (let (#+(or lucid mcl) hold #+(or lucid mcl) new-ideal-diagram)      (handler-case #-(or lucid mcl) (ideal-delete link ideal-diagram)		    #+(or lucid mcl) (setq new-ideal-diagram (ideal-delete link ideal-diagram))		    (simple-error (c)				  #+(or lucid mcl) (setq hold t)				  (beep-message "~a" c))		    #-(or lucid mcl)		    (:no-error (new-ideal-diagram)			       (undraw-self link)			       (structure-changed)			       (setq ideal-diagram new-ideal-diagram)			       (setq link-list (delete link link-list))))      #+(or lucid mcl) (unless hold		(undraw-self link)		(structure-changed)		(setq ideal-diagram new-ideal-diagram)		(setq link-list (delete link link-list)))      )))(defun delete-node (node)  (with-slots (node-list ideal-diagram) *application-frame*    (let (#+(or lucid mcl) hold #+(or lucid mcl) new-ideal-diagram)      (handler-case #-(or lucid mcl) (ideal-delete node ideal-diagram)		    #+(or lucid mcl) (setq new-ideal-diagram (ideal-delete node ideal-diagram))		    (simple-error (c)				  #+(or lucid mcl) (setq hold t)				  (beep-message "~a" c))		    #-(or lucid mcl)		    (:no-error (new-ideal-diagram)			       (setf ideal-diagram new-ideal-diagram)			       (setf node-list (delete node node-list))			       (structure-changed)			       (close-node-editor node)			       (with-unchanged-position ((display))				 (undraw-self node)				 (undraw-links-connected-to-node node)				 (delete-links-connected-to-node node))))      #+(or lucid mcl) (unless hold		(setf ideal-diagram new-ideal-diagram)		(setf node-list (delete node node-list))		(structure-changed)		(close-node-editor node)		(with-unchanged-position ((display))		  (undraw-self node)		  (undraw-links-connected-to-node node)		  (delete-links-connected-to-node node)))      )))(defun clear-connects ()  (let ((x (get-selection *application-frame*)))    (when x (deselect x))));;;----------------(defun redraw-display ()  (let ((frame (get-graph-editor)))    (with-slots (node-list link-list) frame      (window-clear (display))      ;; must draw nodes before links, since links      ;; depend on the existing screen presentation of the nodes.      (mapc #'(lambda (n) (draw-self n)) node-list)      (mapc #'(lambda (l) (draw-self l)) link-list)      (re-display-options))));;;----------------(defmethod draw-links-connected-to-node ((node graph-node))  (let ((frame (get-graph-editor)))    (with-slots (link-list) frame      (mapc #'(lambda (l) (when (is-connected-to l node) (draw-self l)))	      link-list))))(defmethod undraw-links-connected-to-node ((node graph-node))  (let ((frame (get-graph-editor)))    (with-slots (link-list) frame      (mapc #'(lambda (l) (when (is-connected-to l node) (undraw-self l)))	      link-list))))(defmethod delete-links-connected-to-node ((node graph-node))  (let ((frame (get-graph-editor)))    (with-slots (link-list) frame      (setf link-list	    (delete-if #'(lambda (l) (is-connected-to l node))		       link-list)))));;;----------------(defun destroy-graph ()  (with-slots (node-list link-list ideal-diagram) *application-frame*    (mapc #'close-node-editor node-list)    (setf node-list nil)    (setf link-list nil)    (setf ideal-diagram nil)    (window-clear (display))))(defun editor-id (editor)  (with-slots (ideal-diagram) editor    ideal-diagram))(defun time-difference (from-time)  (- (get-internal-run-time) from-time));;;;; COMMANDS MACROS(define-ideal-command (com-exit 		       :menu ("Exit" :documentation "Exit Editor")		       ) ()  (mapc #'close-node-editor (slot-value *application-frame* 'node-list))  (frame-exit *application-frame*));;;----------------(define-ideal-command (com-refresh 		       :menu ("Refresh" :documentation "Redraw Screen")) ()  (clear-connects)				  (with-unchanged-position ((display))    (redraw-display))  (show-mode));;;----------------(define-ideal-command (com-zoom-in :menu ("Zoom In" :documentation					  "Make Node Rendering Larger")) ()  (clear-connects)  (scale-display 1.3)  (redraw-display))(define-ideal-command (com-zoom-out :menu ("Zoom Out" :documentation					  "Make Node Rendering Smaller")) ()  (clear-connects)  (scale-display 0.75)  (redraw-display));;;----------------(define-ideal-command (com-showing-options 		       :menu ("Drawing Options"			      :documentation "Sub-Menu to Select Options")) ()  (clear-connects)  (multiple-value-bind (val item gesture)      (menu-choose (showing-options-menu))    (declare (ignore item gesture))    (when val (inc-showing-option val))));;;----------------(define-ideal-command (com-delete-diagram :menu ("Delete Diagram" :documentation					  "Delete Currently Displayed Diagram")) ()  (structure-changed)  (clear-connects)  (destroy-graph))(define-ideal-command (com-delete-object :menu ("Delete Object" :documentation					  "Delete Currently Selected Object")) ()  (let ((obj (get-selection *application-frame*)))    (when obj      (deselect obj)      (cond ((typep obj 'link) (delete-link obj))	    ((typep obj 'graph-node) (delete-node obj))))));;;----------------	;;;----------------(defvar *node-types*   '(probability-node noisy-or-node deterministic-node decision-node value-node none))(define-ideal-command (com-select-node-type		       :menu ("Node Types to Add"			      :documentation "Sub-Menu to Select Type of Node to Create"))    ()  (with-slots (add-node-type) *application-frame*    (let ((nt (menu-choose *node-types*)))      (when nt	(setf add-node-type nt)	(show-mode)))));;;----------------(define-ideal-command (com-reset-evidence 		       :menu ("Reset Evidence"			      :documentation "Delete all Evidence in Diagram"))    ()  (clear-connects)  (with-slots (ideal-diagram node-list) *application-frame*    (handler-case (ideal:remove-evidence ideal-diagram)      (simple-error (c)	(beep-message "~a" c)))    (with-unchanged-position ((display))      (mapc #'touch-node node-list))));;;----------------(define-ideal-command (com-select-solver 		       :menu ("Select Solver"			      :documentation "Sub-Menu to Select Diagram Solution Algorithm"))    ()  (clear-connects)  (with-slots (solve-menu solve-algorithm solve-name) *application-frame*    (multiple-value-bind (val item gesture)	(menu-choose solve-menu 		     #-genera :pointer-documentation		     #-genera (get-frame-pane *application-frame* 'pointer))      (declare (ignore gesture))      (setf solve-algorithm val)      (setf solve-name (car item))      (show-mode))));;;----------------(define-ideal-command (com-load-file 		       :menu ("Load File" 			      :documentation "Load Diagram From File")) ()  (with-slots (filename) *application-frame*    (let (newname file-list (stream (messages)) 	  (extra-character-width 40)	  (extra-line-height 1)	  #+(or lucid mcl) hold	  )      (fresh-line (messages))      (setq file-list (directory #-allegro (merge-pathnames ideal:*default-diag-path-name* "*.diag")				 #+allegro ideal:*default-diag-path-name*				 ))      #+allegro (setq file-list		  (loop for file in file-list		      for name = (namestring file)		      if (equal ".diag" (subseq name (max (- (length name) 5) 0)))		      collect file))      (if file-list	  (progn	    (setq file-list (sort file-list #'(lambda(x y) (string> (namestring x)(namestring y)))))	    (setq file-list	      (reverse (cons (list "<OTHER>"				   :value "OTHER"				   #-mcl :style				   #-mcl (make-text-style :fix :italic :normal)) 			     file-list))	      )	    (setf newname	      (menu-choose (mapcar #'(lambda(z) (if (listp z) z (cons (pathname-name z) z)						    )) file-list)))	    )	(setq newname "OTHER")	)      (when (equal newname "OTHER")	(setq newname (enough-namestring filename))	(setq newname (accepting-values (stream 					 :own-window 					 (list :right-margin					       (* (stream-string-width stream " ")						  extra-character-width)					       :bottom-margin					       (* (stream-line-height stream)						  extra-line-height)					       ))					(accept 'string :stream stream						:prompt "File to Read From"						:default newname)					))	)      (when newname        (handler-case (read-graph-from-file *application-frame* newname)          (error (c)            (beep-message "~a" c)	    #+(or lucid mcl) (setq hold t);;            (setf filename nil)	    )	  #-(or lucid mcl)          (:no-error (x)            (declare (ignore x))            (setf filename newname)            (show-mode)	    )	  )	#+(or lucid mcl) (unless hold (setf filename newname)(show-mode))	)))  (structure-changed)  (clear-connects)  (redraw-display))(define-ideal-command (com-save-file 		       :menu ("Save File"			      :documentation "Save Diagram to File")) ()  (with-slots (filename) *application-frame*    (clear-connects)    (let (newname 	  (stream (messages))	  (extra-character-width 40)	  (extra-line-height 1)	  #+(or lucid mcl) hold	  )      (fresh-line stream)      (setq newname (enough-namestring filename))      (setq newname (accepting-values (stream 				       :own-window 				       (list :right-margin					     (* (stream-string-width stream " ")						extra-character-width)					     :bottom-margin					     (* (stream-line-height stream)						extra-line-height)					     ))				      (accept 'string :stream stream					      :prompt "File to Save to"					      :default newname)				      ))      (when newname	(handler-case (save-graph-to-file *application-frame* newname)	  (error (c)	    (beep-message "~a" c)	    #+(or lucid mcl) (setq hold t)	    (setf filename nil))	  #-(or lucid mcl)	  (:no-error (x)	    (declare (ignore x))	    (setf filename newname)	    (show-mode))	  )	#+(or lucid mcl) (unless hold (setf filename newname) (show-mode))	))))(define-ideal-command (com-read-diagram 		       :menu ("Read Diagram"			      :documentation "Get Diagram from Lisp Expression"))    ()  (clear-connects)  (setf ideal:*diagram* (slot-value *application-frame* 'ideal-diagram))  (fresh-line (messages))  (let ((sexpr	 (accept 'expression		 :stream (messages)		 :default nil		 :prompt "Lisp Expression for IDEAL Diagram"))	#+(or lucid mcl) hold #+(or lucid mcl) new-diagram	)    (when sexpr      (handler-case #-(or lucid mcl) (car (multiple-value-list (eval sexpr)))		    #+(or lucid mcl) (setq new-diagram (car (multiple-value-list (eval sexpr))))        (simple-error (c)	  #+(or lucid mcl) (setq hold t)	  (beep-message "~a" c))	#-(or lucid mcl)	(:no-error (new-diagram)	  (create-graph-from-ideal *application-frame* new-diagram))	)      #+(or lucid mcl) (unless hold (create-graph-from-ideal *application-frame* new-diagram))    (layout-graph *application-frame*)    (redraw-display)      )))	(define-ideal-command (com-solve-diagram :menu t) ()  (clear-connects)  (with-slots (node-list link-list ideal-diagram	       solve-algorithm solution-generation) *application-frame*    (let ((start-time (get-internal-run-time))	  #+(or lucid mcl) hold #+(or lucid mcl) new-diagram	  )      (cond (solve-algorithm	     (handler-case #-(or lucid mcl) (funcall solve-algorithm ideal-diagram)			   #+(or lucid mcl) (setq new-diagram					 (funcall solve-algorithm ideal-diagram))	       (simple-error (c)		 #+(or lucid mcl) (setq hold t)		 (beep-message "~a" c))	       (error (c)		 #+(or lucid mcl) (setq hold t)		 (beep-message "~a" c))	       #-(or lucid mcl)	       (:no-error (new-diagram)		 (setf ideal-diagram new-diagram)		 (show-message 			 "~&Solution time: ~d"			 (time-difference start-time))		 (incf solution-generation)		 (with-unchanged-position ((display))		   (mapc #'touch-node node-list)		   (mapc #'redraw-self link-list)))	       )	     #+(or lucid mcl) (unless hold 		       (setf ideal-diagram new-diagram)		       (show-message 			"~&Solution time: ~d"			(time-difference start-time))		       (incf solution-generation)		       (with-unchanged-position ((display))			 (mapc #'touch-node node-list)			 (mapc #'redraw-self link-list)))	)     	    (t	     (beep-message "No solution algorithm selected!"))))));;;----------------(define-ideal-command (com-id-commands		       :menu ("ID Operations"			      :documentation "Sub-Menu of Operations for Influence Diagrams")) ()  (let ((comm (menu-choose-command-from-command-table 'id-commands)))    (when comm      (execute-frame-command *application-frame* comm))));;;----------------;;;   ooooooo             NON-MENU NODE COMMANDS;;;----------------;;;----------------(define-ideal-command (com-add-new-node) ((x 'number) (y 'number))  (with-slots (add-node-type node-list ideal-diagram) *application-frame*    (when (not (eq add-node-type 'none))      (let ((new-node (make-instance add-node-type))	    #+(or lucid mcl) hold #+(or lucid mcl) new-ideal-diagram	    )	(with-slots (center-x center-y display-record) new-node	  (setf center-x x		center-y y)	  (handler-case #-(or lucid mcl) (ideal-init new-node ideal-diagram)			#+(or lucid mcl) (setq new-ideal-diagram				      (ideal-init new-node ideal-diagram))	    (simple-error (c)			  #+(or lucid mcl) (setq hold t)			  (beep-message "~a" c))	    #-(or lucid mcl)	    (:no-error (new-ideal-diagram)	     (structure-changed)	     (setf ideal-diagram new-ideal-diagram)	     (push new-node node-list)	     (draw-self new-node)))	  #+(or lucid mcl) (unless hold		    (structure-changed)		    (setf ideal-diagram new-ideal-diagram)		    (push new-node node-list)		    (draw-self new-node))	     )))));;; the following selects a point somewhere on the screen.(define-presentation-to-command-translator point-to-add-translator    (blank-area com-add-new-node graph-editor		:gesture :left-button)  (x y)  (multiple-value-bind (real-x real-y)      (untransform-position (display-xform) x y)    (list real-x real-y)));;;; The following desects if you middle click over nothing(define-ideal-command (com-deselect) ((x 'number) (y 'number))  (let ((obj (get-selection *application-frame*)))    x y    (when obj      (deselect obj))))(define-presentation-to-command-translator point-to-del-translator    (blank-area com-deselect graph-editor :gesture :middle-button)  (x y)  (list x y));;;----------------(define-ideal-command (com-select-node)    ((node 'graph-node :gesture :middle-button))  (let ((selected (get-selection *application-frame*)))    (cond ((or (null selected) (typep selected 'link))	   (select-it node)	   )	  ((eq node selected)	   (deselect node)	   ;;; unhighlight node	     )	  ((typep selected 'graph-node)	   (handler-case (connect-nodes *application-frame* selected node)	     (simple-error (c)			   (beep-message "~a" c)))	   (clear-connects)))));(define-ideal-command (com-mark-begin-link);    ((node 'graph-node :gesture :left-button));  (with-slots (cur-begin-node cur-end-node) *application-frame*;     (setf cur-begin-node node);     (when (eq cur-begin-node cur-end-node) ;       (setf cur-end-node nil));     (when cur-end-node ;       (handler-case (connect-nodes *application-frame*);         (simple-error (c);	   (beep-message "~a" c)));       (clear-connects))));;;;;----------------;;(define-ideal-command (com-mark-end-link);    ((node 'graph-node :gesture :middle-button));  (with-slots (cur-begin-node cur-end-node) *application-frame*;     (setf cur-end-node node);     (when (eq cur-begin-node cur-end-node) ;       (setf cur-begin-node nil));     (when cur-begin-node ;       (handler-case (connect-nodes *application-frame*);         (simple-error (c);	   (beep-message "~a" c)));       (clear-connects))));		     ;;;----------------(define-ideal-command (com-edit-node)    ((node 'graph-node :gesture :left-button))  (clear-connects)  (with-slots (node-editor) node    (unless node-editor      (setf node-editor (make-node-editor node *application-frame*)))    (run-node-editor node-editor)));;;----------------;;;----------------(define-ideal-command (com-move-node)    ((node 'graph-node :gesture :right-button))  (clear-connects)  (with-slots (display-record center-x center-y) node    (undraw-links-connected-to-node node)    (multiple-value-setq (center-x center-y)      (drag-output-record (display) display-record			  :finish-on-release #-mcl t #+mcl nil))    (multiple-value-setq (center-x center-y)      (untransform-position (display-xform) center-x center-y))    (undraw-self node)  ; won't end up _quite_ where we would like,    (draw-self node)    ; draw in the place where we really are.    (draw-links-connected-to-node node)));;;----------------;;;   ooooooo             NON-MENU LINK COMMANDS;;;----------------;;;---------------;;; New Arc handling Stuff(define-ideal-command (com-edit-link)    ((link 'link :gesture :left-button))  (let ((op (clim:menu-choose '(("Delete Link" . delete-link)				("Reverse Link" . reverse-link)))))    (when op (funcall op link))))(define-ideal-command (com-select-link)    ((link 'link :gesture :middle-button))  (select-it link))(define-ideal-command (com-remove-node-editors :name t)     ()  (let ((frame (get-graph-editor)))    (with-slots (node-list link-list) frame      (loop for node in node-list            do (with-slots (node-editor) node                 (setq node-editor nil))))))