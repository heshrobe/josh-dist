;;; -*- Mode: LISP; Syntax: Common-Lisp; Base: 10; Package: IDEAL-EDIT -*-(in-package "IDEAL-EDIT");;;;********************************************************;;;;  Copyright (c) 1989, 1992 Rockwell International -- All rights reserved.;;;;  Rockwell International Science Center Palo Alto Lab;;;;********************************************************;;;----------------;;;   ooooooo             ACCESSING INTERNAL NODE STATE;;;----------------;;; we put all node and state names in the keyword package, to;;; avoid problems that can arise when the symbols are not;;; in the ideal, or ideal-edit, packages.  (The only known;;; source of problems in this regard are the functions;;; ideal:true-label and ideal:false-label, which use literal;;; symbol names).  This doesn't catch the names generated;;; by ideal:create-random-diagram, but you can't have everything.(defun keywordize (sym)  (intern (symbol-name sym) 'keyword));;;----------------;;;   ooooooo                   NODE NAMES;;;----------------(defun change-node-name (node new-name)  (let ((name-sym (keywordize new-name)))        ;; we have to do our own error checking here, since we are    ;; playing with ideal's internals.    (when (find-node-named name-sym)      (error "There is already a node named ~a" name-sym))        (with-slots (name ideal-node node-editor) node      (setf name name-sym)      (setf (ideal:node-name ideal-node) name-sym)      ;; Doing the commented out line below screws up      ;; incremental redisplay      ;; (redraw-self node)      )));;;----------------;;;   ooooooo                   NODE STATES;;;----------------(defun change-state-name (node i new-name)  (let ((name-sym (keywordize new-name)))    (with-slots (states) node      ;; we have to do our own error checking here, since we are      ;; playing with ideal's internals.      (when (member name-sym states)	(error "There already is a state named ~a" name-sym))            (setf (ideal::label-name (ideal-state node i)) name-sym)      (setf (elt states i) name-sym))))(defun ideal-delete-state (node old-val)  (let ((ideal-node (slot-value node 'ideal-node)))    (ideal:delete-state ideal-node (ideal-state node old-val))));;; fetch the structure that ideal labels a state with,;;; given its name or index.;;; An error is invoked if no such state exists, _unless_;;; the state was nil, in which case nil is returned. (ugh.)(defmethod ideal-state ((node graph-node) (i number))  (with-slots (states) node    (ideal-state node (elt states i))))(defmethod ideal-state ((node graph-node) (state symbol))  (when state    (let ((s (ideal:get-state-label (slot-value node 'ideal-node) state)))      (unless s (error "~a does not have state ~a" node state))      s)));;;----------------;;;   ooooooo                NODE DISTRIBUTIONS;;;----------------(defun get-ideal-dist (node state cond-case)  (ideal:contents-of (node-case node state) cond-case))(defun set-ideal-dist (node state cond-case new-val)  (setf (ideal:contents-of (node-case node state) cond-case)	new-val));;;----------------(defmethod node-case ((node graph-node) (i number))  (node-case node (elt (slot-value node 'states) i)))(defmethod node-case ((node graph-node) (state symbol))  (with-slots (ideal-node) node    (list (cons ideal-node (ideal-state node state)))));;;----------------(defun change-dist-value (node index cond-case new-value)  ;; simple tests first  (when (or (< new-value 0.0)	    (> new-value 1.0))    (error "~a is not a probability value" new-value))    ;; we want to make sure that the distribution remains a   ;; distribution, so we adopt the following policy:  ;; if the distribution value for state i has changed  ;; by delta, try to change the distribution of  ;; of all other values proportionately  (let ((n (length (slot-value node 'states)))	(delta (- new-value (get-ideal-dist node index cond-case)))	(i 1))    (loop						; -- begin body      (let* ((j (mod (+ index i) n))		; i.e. loop index+1..0..index-1	     (j-val (get-ideal-dist node j cond-case)))	(cond ((plusp delta)	       (cond ((>= (- j-val delta) 0)		      (set-ideal-dist node j cond-case (- j-val delta))		      (setf delta 0))		     (t		      (set-ideal-dist node j cond-case 0)		      (setf delta (- delta j-val)))))	      (t	       (cond ((<= (- j-val delta) 1)		      (set-ideal-dist node j cond-case (- j-val delta))		      (setf delta 0))		     (t		      (set-ideal-dist node j cond-case 1)		      (setf delta (+ delta j-val)))))))						; -- end body      (if (or (not (< i n))	      (zerop delta))	  (return))      (setf i (1+ i))))  (set-ideal-dist node index cond-case new-value));;;----------------;;;   ooooooo                     BELIEFS;;;----------------(defmethod belief-val ((node probability-node) state)  (ideal:belief-of (node-case node state)))(defmethod belief-exists ((node probability-node))  (with-slots (ideal-node) node      (if (ideal::node-bel ideal-node) t nil))) ; #|(defmethod belief-exists ((node probability-node))  (handler-case (ideal:belief-of (node-case node 0))    (simple-error (c)      (declare (ignore c))      nil)    (:no-error (x)      (declare (ignore x))      t)))|#;;;----------------;;;   ooooooo                     EVIDENCE;;;----------------;;;;;; Evidence is complicated in ideal:;;; There are three kinds of evidence (none, concrete and virutal),;;; each of which is stored in a differant format, and two evidence;;; states (current and old), which are stored as two different;;; fields of an ideal-node.  [The old evidence is used internally,;;; though, and we do not have to mess with it.](defun evidence-type (node)  "return nil, 'concrete or 'virtual according to the type of evidence"  (with-slots (ideal-node) node    (if ideal-node 	(let ((ideal-evidence (ideal::node-state ideal-node)))	  (cond ((null ideal-evidence) nil)		((listp ideal-evidence) 'virtual)		(t 'concrete))))));;;----------;;; returns display-able item indicating evidence type(defmethod get-evidence ((node graph-node) (i number))  (get-evidence node (elt (slot-value node 'states) i)))(defmethod get-evidence ((node graph-node) (s symbol))  (with-slots (ideal-node) node    (let ((ideal-evidence (ideal::node-state ideal-node)))      (case (evidence-type node)	((nil) "***")	((virtual)	  (cdr (assoc (ideal-state node s) ideal-evidence)))	((concrete)	 (if (eq (ideal::label-name ideal-evidence) s)	     "xxx"	     "---"))))));;;----------;;; set or reset evidence(defun clear-evidence (node)  (with-slots (ideal-node) node    (when (ideal::node-state ideal-node)      (setf (ideal::node-state ideal-node) nil))))(defmethod set-virtual-evidence ((node graph-node) (i number) (new-val number))  (set-virtual-evidence node (elt (slot-value node 'states) i) new-val))(defmethod set-virtual-evidence ((node graph-node) (s symbol) (new-val number))  (with-slots (ideal-node) node    (init-virtual-evidence node)    (rplacd (assoc (ideal-state node s) (ideal::node-state ideal-node))	     new-val)))(defun init-virtual-evidence (node)  (unless (eq (evidence-type node) 'virtual)    (with-slots (ideal-node states) node      (setf (ideal::node-state ideal-node) ; make assoc list of 1's	    (mapcar #'(lambda (s)	                (cons (ideal-state node s) 1))		      states)))))(defmethod set-concrete-evidence ((node graph-node) (i number))  (set-concrete-evidence node (elt (slot-value node 'states) i)))(defmethod set-concrete-evidence ((node graph-node) (s symbol))  (with-slots (ideal-node) node    (setf (ideal::node-state ideal-node)          (ideal-state node s))))