;; -*- Mode: LISP; Syntax: Common-Lisp; Base: 10; Package: IDEAL-EDIT -*-(in-package "IDEAL-EDIT");;;;********************************************************;;;;  Copyright (c) 1989, 1992 Rockwell International -- All rights reserved.;;;;  Rockwell International Science Center Palo Alto Lab;;;;********************************************************;;;----------------;;;   ooooooo        NODE-EDITOR TABLE DISPLAY;;;----------------;;;;;; Each different node type has a slightly different format,;;; so we just displatch first on the node.(defun ne-displayer (ne stream)  (with-slots (node) ne    (display-table node stream)))	(defun table-refresh ()  (window-refresh (get-frame-pane *application-frame* 'table)));;;----------;;; The basic layout of the table for all the node types looks;;; something like this:;;;;;;             <parent names>  <state names>;;;   Dist:     < cond-cases >  < values >;;;                 ...             ...;;;   Evidence:                 < evidence >;;;   Belief:                   < belief >;;;;;; Each node type has a variation on the above, reflecting its;;; purpose.  Generally, the state names, values, and evidence;;; are editable.;;;----------;;; The following macro captures the common pattern: it displays;;; one editable value in the table.  When the value is edited,;;; the associated code ('body') is executed.;;; note: it assumes the variable 'stream' is appropriately bound(defmacro accept-val (val type id &body body)  `(formatting-cell (stream)    (multiple-value-bind (new-val new-type val-changed)	(accept ,type		:stream stream		:default ,val		:prompt nil		:query-identifier ,id)      (declare (ignore new-type))      (when val-changed	(handler-case (progn ,@body)	  (simple-error (c)			(show-error "~a" c)))))));;;----------;;; create an empty cell(defmacro empty-cell ((stream))  `(formatting-cell (,stream)    (declare (ignore ,stream))    nil));;;----------;;; This macro loops over all the conditioning cases for the;;; parents of a node -- it displays the conditional values;;; and then evaluates the body (which displays whatever values;;; are associated with that conditioning case).;;;;;; The argument 'cond-case' is set to the (destructively-;;; modified) conditioning case within the body.  Additionally,;;; the variable 'row' is set to the row number. (defmacro display-cond-cases-loop (block-label				   parent-list				   cond-case &rest body)  `(let ((row 0)	 (ideal-parents (mapcar #'(lambda (n) (slot-value n 'ideal-node))			 ,parent-list)))    ;; loop over all conditioning cases of the parents    (ideal:for-all-cond-cases (,cond-case ideal-parents)     (formatting-row (stream)      (incf row)      ;; label this block of the table      (formatting-cell (stream)       (when (= row 1)	 (princ ,block-label stream)))      ;; display the cond-case      (when ,cond-case	(mapc #'(lambda (p)		  (formatting-cell (stream)		    (princ 		        ;; pull the state label associated with			;; node p out of the cond-case list,			;; which happens to be an association list		     (ideal::label-name		      (cdr (assoc (slot-value p 'name)				  ,cond-case 				  :key #'ideal:node-name)))		     stream)))	      ,parent-list))      ;; now do rest of the line      ,@body))))(defun display-cond-case (node stream)  (with-slots (states node-editor) node    (let ((cond-case (get-cond-case node-editor)))      (when cond-case	(formatting-row (stream)	  (formatting-cell (stream)	    (princ "Case:" stream))	  ;; display the cond-case	  (mapc #'(lambda (p)		    (formatting-cell (stream)		      (princ (ideal::label-name (ideal:state-in (list p))) stream)))		cond-case))))))		;;;----------;;; some methods that are used by several different;;; node types(defmethod display-parent-names ((node graph-node) parent-list stream)  (declare (ignore parent-list))  (with-slots (node-editor) node    (let ((cond-case (get-cond-case node-editor)))      (when cond-case	(formatting-row (stream)	  (formatting-cell (stream)	    (princ "Parents:" stream))	  (mapc #'(lambda (p)		    (formatting-cell (stream)		      (princ (ideal:node-name (ideal:node-in (list p))) stream)))		cond-case))))));  (formatting-row (stream);    (formatting-cell (stream);        (princ "Parents:" stream));    (mapc #'(lambda (p);	      (formatting-cell (stream);		(princ (slot-value p 'name) stream)));	  parent-list)))(defmethod display-state-names ((node graph-node) stream) ;; display and accept new state names  (with-slots (states) node    (dotimes (i (length states))      (accept-val        (elt states i) 'symbol (list 'states node i)       (change-state-name node i new-val)))))(defmethod skip-over-columns (parent-list stream)  (dolist (p parent-list)    (empty-cell (stream))))(defun display-node-name (node stream)  (with-text-style     (stream (make-text-style :sans-serif :bold nil))      (accept-val (slot-value node 'name) 'symbol (list 'name node 1)	(change-node-name node new-val))));;;----------------;;;   ooooooo             PROBABILITY NODE TABLE;;;----------------;;; Decompose recursively into rows, then columns.(defmethod display-table ((node probability-node) stream)	  (let ((parent-list (get-parents-of-node node)))    (formatting-table (stream)      (display-top-row node parent-list stream)      (display-belief node parent-list stream)      (display-evidence node parent-list stream)      (display-parent-names node parent-list stream)      (display-cond-case node stream)      (display-distribution node parent-list stream)      )))(defun display-top-row (node parent-list stream)  (formatting-row (stream)    (display-node-name node stream)    (display-state-names node stream)))(defun display-distribution (node parent-list stream)  (with-slots (states node-editor) node    (formatting-row (stream)      (let ((cond-case (get-cond-case node-editor)))	(formatting-cell (stream)	  (accept-values-command-button (stream :query-identifier (list 'd node))	      (princ "Dist [Next]:" stream)	    (next-cond-case *application-frame*)))	;; loop over all states	(dotimes (i (length states))	  ;; display each distribution value	  (accept-val 	    (get-ideal-dist node i cond-case) 'probability-value (list node i 0)	    (change-dist-value node i cond-case new-val)))))))(defun display-evidence (node parent-list stream)  (formatting-row (stream)    (display-evidence-button node stream)    (display-evidence-states node stream)))(defun display-belief (node parent-list stream)  (with-slots (states ideal-node) node    (formatting-row (stream)      (formatting-cell (stream)        (princ "Belief:" stream))      (cond ((belief-exists node)	     (dotimes (i (length states))	       (formatting-cell (stream)		 (format stream "~4,3F" (belief-val node i)))))	    (t	     (dotimes (i (length states))	       (formatting-cell (stream)		 (princ "***" stream))))))));;;----------------;;;   ooooooo            NOISY-OR-NODE TABLE;;;----------------;;; Decompose recursively into rows, then columns.(defmethod display-table ((node noisy-or-node) stream)	  (let ((parent-list (get-parents-of-node node)))    (formatting-table (stream)      (display-top-row node parent-list stream)      (display-parent-inhibitor-probs node parent-list stream)      (display-evidence node parent-list stream)      (display-belief node parent-list stream)      )))(defun display-parent-inhibitor-probs (node parent-list stream)  (let ((s-node (slot-value node 'ideal-node)))    (dolist (parent parent-list)      (with-slots (name ideal-node) parent	(formatting-row (stream)	  (formatting-cell (stream)	    (princ name stream))	  (ideal:for-all-cond-cases (cc (list ideal-node))	    (mapc #'(lambda (p)		      (formatting-cell (stream)			(princ (ideal::label-name (ideal:state-in (list p))) stream)))		  cc)))	(formatting-row (stream)	  (formatting-cell (stream)	    (princ "" stream))	  (ideal:for-all-cond-cases (cc (list ideal-node))	    (accept-val 	      (ideal:inhibitor-prob-of s-node cc) 'probability-value	      (list (ideal:copy-conditioning-case cc))	      (setf (ideal:inhibitor-prob-of s-node cc) new-val))))))));;;----------------;;;   ooooooo              FUNCTION NODE TABLE;;;----------------;(defmethod display-table ((node deterministic-node) stream);  (let ((parent-list (get-parents-of-node node)));    (formatting-table (stream);      ;; row 1;      (formatting-row (stream);	(formatting-cell (stream);	  (princ "States:" stream));	(display-state-names node stream));      ;; row 2;      (formatting-row (stream);	(formatting-cell (stream);          (princ "Parents:" stream));        (display-parent-names node parent-list stream);	(formatting-cell (stream);	  (princ "Value:" stream)));      ;; main table;      (display-function-table node parent-list stream))))(defmethod display-table ((node deterministic-node) stream)  (let ((parent-list (get-parents-of-node node)))    (formatting-table (stream)      ;; row 1      (formatting-row (stream)	(display-node-name node stream)	)      (formatting-row (stream)	(formatting-cell (stream)	  (princ "Legal Values:" stream))	(display-state-names node stream))      (display-det-value node parent-list stream)      (display-parent-names node parent-list stream)      (display-cond-case node stream))))(defun display-det-value (node parent-list stream)  (with-slots (node-editor states) node    (formatting-row (stream)      (let ((cond-case (get-cond-case node-editor)))	(formatting-cell (stream)	  (accept-values-command-button (stream :query-identifier (list 'd node))	      (princ "Value [Next]:" stream)	    (next-cond-case *application-frame*)))	  ;; display value	  (accept-val 	    (ideal::label-name (get-ideal-dist node nil cond-case))	    'symbol	    ;(list 'alist-member (mapcar '#(lambda(z);					    (cons (string z) (ideal-state node z)));					    states))	    (list 'f node 0)	    (set-ideal-dist node nil cond-case (ideal-state node new-val)))))));(defun display-function-table (node parent-list stream);  (with-slots (states) node;    (display-cond-cases-loop "Func:" parent-list cond-case;      (accept-val ;       (ideal::label-name (get-ideal-dist node nil cond-case));       'symbol (list 'f node row);       (set-ideal-dist node nil cond-case (ideal-state node new-val))))));;;----------------;;;   ooooooo                VALUE NODE TABLE;;;----------------(defmethod display-table ((node value-node) stream)  (let ((parent-list (get-parents-of-node node)))    (formatting-table (stream)      ;; row 1      (formatting-row (stream)	(display-node-name node stream))      (display-value node parent-list stream)      (display-parent-names node parent-list stream)      (display-cond-case node stream))))(defun display-value (node parent-list stream)  (with-slots (node-editor) node    (formatting-row (stream)      (let ((cond-case (get-cond-case node-editor)))	(formatting-cell (stream)	  (accept-values-command-button (stream :query-identifier (list 'd node))	      (princ "Value [Next]:" stream)	    (next-cond-case *application-frame*))) 	  ;; display value	  (accept-val 	    (get-ideal-dist node nil cond-case) 'number (list node 'val 0)	    (set-ideal-dist node nil cond-case new-val))))))      ;;;----------------;;;   ooooooo              DECISION NODE TABLE;;;----------------(defmethod display-table ((node decision-node) stream)  (with-slots (solved-node node-editor) node    (formatting-table (stream)      (formatting-row (stream)	(display-node-name node stream)	(display-state-names node stream))      (cond (solved-node	     ;; the table we display is not according to the graph,	     ;; but rather according to the mangled graph produced	     ;; when we last solved the diagram.	     (let ((parent-list (ideal:node-predecessors solved-node)))	       (display-decision-value node stream)	       (display-parent-names node parent-list stream)	       (display-cond-case node stream)))	    (t	     (formatting-row (stream)	       (formatting-cell (stream)		 (princ "No Decision Reached" stream))))))))(defun display-decision-value (node stream)  (with-slots (solved-node node-editor) node    (let ((cond-case (get-cond-case node-editor)))      (formatting-row (stream)	(formatting-cell (stream)	  (accept-values-command-button (stream :query-identifier (list 'd node))	      (princ "Policy [Next]:" stream)	    (next-cond-case *application-frame*))) )      (formatting-row (stream)	(formatting-cell (stream)	  (princ " Decision:" stream))	(formatting-cell (stream)	  (princ	    (cdr (ideal:contents-of (list (cons solved-node nil)) cond-case))	    stream)))      (formatting-row (stream)	(formatting-cell (stream)	  (princ " Expectation:" stream))	(formatting-cell (stream)	  (princ	    (car (ideal:contents-of (list (cons solved-node nil)) cond-case))	    stream))))));;;----------------;;;   ooooooo              EVIDENCE DISPLAY;;;----------------;;; this is kind of complicated:;;;   there are three possible kinds of evidence: ;;;	none, concrete and virtual.;;;   you can click on either the evidence button (EB),;;;   on one of state evidence items (ST), giving the;;;   following transition diagram:;;;;;;                  |       EB           ST                               ;;;      ------------+--------------------------;;;      no evidence |     virtual      concrete                        ;;;      virtual     |   no evidence    virtual;;;      concrete    |   no evidence    concrete;;;;;; in the case of the virtual->virtual and concrete->concrete;;; transitions, you change the actual value of the evidence.(defun display-evidence-button (node stream)  (formatting-cell (stream)    (accept-values-command-button (stream :query-identifier node)      (princ "Evidence:" stream)      (progn	(if (evidence-type node)	    (clear-evidence node)	    (init-virtual-evidence node))	(redraw-self node)))))(defun display-evidence-states (node stream)  (case (evidence-type node)    ((nil concrete)     (display-no-or-concrete-evidence node stream))    ((virtual)     (display-virtual-evidence node stream))))(defun display-no-or-concrete-evidence (node stream)  (with-slots (states) node    (mapc #'(lambda (state)	      (formatting-cell (stream)		(let ((ev (get-evidence node state)))		  (accept-values-command-button (stream						 :query-identifier						 (list 'e node state)						 :cache-value ev)		  (princ ev stream)		  (set-concrete-evidence node state)		  (redraw-self node)))))	  states)))(defun display-virtual-evidence (node stream)  (with-slots (states) node    (mapc #'(lambda (state)	      (accept-val	       (get-evidence node state) 'number (list 'e node state)	       (set-virtual-evidence node state new-val)))	  states)));;;;; Probability(clim:define-presentation-type probability-value () :inherit-from 'number)(clim:define-presentation-method clim:present				 (probability-value (type probability-value) stream						    (view clim:textual-view) &key)  (format stream "~4,3F" probability-value))(clim:define-presentation-method clim:presentation-typep				 (object (type probability-value))  (and (numberp object)       (>= 1 object 0)))