;;; -*- Mode: LISP; Syntax: Common-Lisp; Base: 10; Package: IDEAL-EDIT -*-(in-package "IDEAL-EDIT");;;;********************************************************;;;;  Copyright (c) 1989, 1992 Rockwell International -- All rights reserved.;;;;  Rockwell International Science Center Palo Alto Lab;;;;********************************************************;;; pkg-symbol;;;;;;  returns a symbol in pkg of specified name;;;  works for symbols and strings(defun pkg-symbol (sym &optional (pkg *package*))  (let* ((sym-str1 (string-upcase (format nil "~a" sym)))	      ;;; ~a turns :a to "a",":a" to ":a"	 (sym-str2 (string-upcase (format nil "~s" sym)))	      ;;; ~s turns :a to ":a",":a" to "\":a\""	 pkg-sym col-pos	 )    (setq pkg-sym	  (cond ( (eq (elt sym-str2 0) #\:)   ;;; sym is :a		 sym)		( (eq (elt sym-str1 0) #\:)   ;;; sym is :a		 (intern (subseq sym-str1 1) (find-package :keyword)))		( (setq col-pos (position #\: sym-str1 :from-end t))                              ;;; sym is ":a" or "user::ab"		 (intern (subseq sym-str1 (1+ col-pos)) pkg)		  )		(t (intern sym-str1 pkg))		))    pkg-sym    ))(defun ideal-edit-symbol (symbol)  (pkg-symbol symbol :ideal-edit))(defun ideal-symbol (symbol)  (pkg-symbol symbol :ideal));;;----------------;;;   ooooooo               GRAPH I/O;;;----------------(defmethod save-graph-to-file ((frame graph-editor) file-name)  (ideal:save-diagram file-name (slot-value frame 'ideal-diagram))  (with-open-file (out ; (merge-pathnames file-name *edit-path-suffix*)		       ; Instead ...		       (get-aux-file-name file-name)		       :direction :output		       :if-does-not-exist :create		       :if-exists :new-version)    (with-slots (node-list) frame      (dolist (node node-list)	(write-node node out)))))(defmethod read-graph-from-file ((frame graph-editor) file-name)  (create-graph-from-ideal frame (ideal:load-diagram file-name))  (with-open-file (in ; (merge-pathnames file-name *edit-path-suffix*)		      ; Instead ...		       (get-aux-file-name file-name)		      :direction :input		      :if-does-not-exist nil)    (cond (in	   (loop	     (let* ((ntype-gen (read in nil :eof))		    ntype		   )	       (when (eq ntype-gen :eof)		 (return))	       (setq ntype (ideal-edit-symbol ntype-gen))	       (unless (typep ntype 'node-types)		 (error "File does not appear to be a graph file"))	       (let* ((node-name (read in))		      (node-name-ideal (ideal-symbol node-name))		      (node (find-node-named node-name-ideal))		     )		 (unless node		   (error "Graph file does not match ideal file"))		 (read-node node in)))))	  (T	   (layout-graph frame)	   ))))	  ;;;----------------(defun get-aux-file-name (p)  (merge-pathnames   (make-pathname :host (pathname-host p)		  :device (pathname-device p)		  :directory (pathname-directory p)		  :name (pathname-name p))   *edit-path-suffix*))		  (defun check-file-name (file-name)  (when (pathname-type file-name)    ;; yuck.  why can't I just take the damn thing off?    (error "Sorry: please specify file name without extension")));;;----------------;; we don't have to store all of our information,;; since ideal already keeps some of it.(defmethod write-node ((node graph-node) stream)  (fresh-line stream)  (with-slots (name center-x center-y) node    (format stream "~S ~S ~D ~D" 	    (type-of node) name center-x center-y)))(defmethod read-node ((node graph-node) stream)  (with-slots (center-x center-y) node    (setf center-x (read stream))    (setf center-y (read stream))));;;----------------;;;   ooooooo             IDEAL --> GRAPH;;;----------------; Punting the punt (15 Jun 92) coz Noisy Or nodes have now been; implemented in IDEAL.;; -- Basically, punting the noise-or-node feature for now;(defun ideal::noisy-or-node-p (ignore);  (values nil));;(export 'ideal::noisy-or-node-p "IDEAL");---------------------------------------------------------------(defmethod create-graph-from-ideal ((frame graph-editor) diagram				    &optional (old-nodes nil))  (with-slots (node-list link-list ideal-diagram) frame    (setf node-list nil)    (setf link-list nil)    (setf ideal-diagram diagram)    (dolist (ideal-node ideal-diagram)      (let* ((type (cond ((ideal:value-node-p ideal-node)			  'value-node)			 ((ideal:decision-node-p ideal-node)			  'decision-node)			 ((ideal:noisy-or-node-p ideal-node)			  'noisy-or-node)			 ((eq (ideal:relation-type ideal-node) :det)			  'deterministic-node)			 (t 'probability-node)))	     (new-node (make-instance type)))	(setf (slot-value new-node 'ideal-node) ideal-node)	(setf (slot-value new-node 'name) (ideal:node-name ideal-node));;	(set-location new-node old-nodes)	(read-ideal-states new-node ideal-node)	(push new-node node-list)))    (dolist (ideal-node ideal-diagram)      (dolist (parent (ideal:node-predecessors ideal-node))	(push	 (make-instance 'link			:from (find-node-named (ideal:node-name parent))			:to (find-node-named (ideal:node-name ideal-node)))	 link-list)))))(defun layout-graph (frame &optional (dx 120) (dy 100) (xstart 100) (ystart 100))  (with-slots (node-list ideal-diagram) frame    (let* ((nodelist (ideal:order (copy-list ideal-diagram)))	   (depth-list (mapcar #'(lambda (z) (cons z 0)) nodelist))	   (ct 0))      (dolist (n nodelist)	(when (ideal:node-predecessors n)	  (rplacd (assoc n depth-list)		  (1+ (apply #'max (mapcar #'(lambda(z) (cdr (assoc z depth-list)))					   (ideal:node-predecessors n)))))))      (setq depth-list (sort depth-list #'< :key #'cdr))      (set-node-locations depth-list frame xstart ystart xstart ystart dx dy ))))(defun set-node-locations       (depth-list frame xdepth ydepth xstart ystart dx dy	&optional (sflag 'up) (stagger .8))	; Staggers nodes on X dimension						;value of 1.0 turns stagger off  (with-slots (center-x center-y)	      (find-node-named (ideal:node-name (car (first depth-list))) :frame frame)    (setf center-x xdepth)    (setf center-y (- ydepth (if (eq sflag 'up) (* stagger dy) 0))))  (cond ((null (cdr depth-list)) 'finished)	((= (cdr (first depth-list)) (cdr (second depth-list)))	 (set-node-locations (cdr depth-list) frame			     (+ xdepth dx) ydepth  xstart ystart dx dy			     (if (eq sflag 'up) 'down 'up)))	(T (set-node-locations (cdr depth-list) frame			       xstart (+ ydepth dy) xstart ystart dx dy))))(defmethod read-ideal-states ((our-node graph-node) ideal-node)  (with-slots (states) our-node    (setf states (mapcar #'ideal::label-name			 (ideal:state-labels ideal-node)))))(defmethod read-ideal-states ((our-node value-node) ideal-node)  (declare (ignore ideal-node))  ())