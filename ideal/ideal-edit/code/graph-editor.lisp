;;; -*- Mode: LISP; Syntax: Common-Lisp; Base: 10; Package: IDEAL-EDIT -*-(in-package "IDEAL-EDIT");;;;********************************************************;;;;  Copyright (c) 1989, 1992 Rockwell International -- All rights reserved.;;;;  Rockwell International Science Center Palo Alto Lab;;;;********************************************************;;;----------------;;;   ooooooo                   GRAPH EDITOR;;;----------------;;;;;; The main display is the graph editor, which shows the graph;;; graphically, and allows editing of the structure of the graph,;;; plus operations on the graph as a whole.;;;----------------;;; A separate command table for the minor influence diagram;;; commands.(define-command-table id-commands);;;----------------;;;   ooooooo             GRAPH EDITOR DESCRIPTION;;;----------------(define-application-frame graph-editor ()  ((ideal-diagram :initform nil)   (node-list :initform nil)   (link-list :initform nil)   (graph-structures :initform (make-hash-table))					   ; e.g. join-tree, whatever   (add-node-type :type node-types :initform 'probability-node)   (showing-options :initform (make-options-table))   (cur-begin-node :initform nil)          ; nodes marked as   (cur-end-node   :initform nil)          ; endpoints of link   (transform      :initform +identity-transformation+) ; for zoom   (filename       :initform  (merge-pathnames			       ideal:*default-diag-path-name*			       (make-pathname :name "foo")))   (solve-menu     :initform (define-solve-menu))   (solve-algorithm :initform nil)   (solve-name     :initform nil)   (solution-generation :initform 0)       ; generation count of solutions   (structure-generation :initform 0))     ; generation count of structural                                           ; changes (used to keep clique-trees                                           ; etc. in sync.)  (:menu-bar nil)  (:panes    #-mcl    (title :title	   :max-height 28	   :display-string "Ideal Edit")     #-genera    (pointer :pointer-documentation :borders t	     :max-height '(1 :line))    (display :application	     :scroll-bars t	     :borders t)    (menu :command-menu 	  :height :compute	  :display-function '(display-command-menu :n-columns 6 :row-wise t)	  :scroll-bars nil	  :borders t)    (mode :application	  :max-height '(3 :line)	  :display-function 'show-mode	  :display-after-commands t	  :scroll-bars nil	  :borders t	  :scroll-bars t)    (messages :interactor	      :max-height '(7 :line)	      :min-height '(4 :line)	      :initial-cursor-visibility :off	      :scroll-bars :vertical	      :end-of-line-action :wrap))  (:layouts    (the-layout      (vertically ()	#-mcl title	(:fill display)	menu	#-genera	pointer	(.05 mode)	(.2 messages))))  (:command-definer define-ideal-command)  (:command-table (graph-editor :inherit-from (id-commands))))#+genera(clim:define-genera-application graph-editor  :pretty-name "Ideal Edit"  :select-key #\circle  );;;;;; work-around for clim bug #163: erase output record doesn't work;;;#|(defmethod initialize-instance :after ((frame graph-editor) &key)  (setf (output-recording-stream-output-record (display :frame frame))	(make-instance 'clim::linear-output-record)))(defmethod initialize-instance :after ((frame graph-editor) &key)  (let ((win (get-frame-pane frame 'messages)))    (with-text-size (:smaller win)      (format win	      "Copyright by Rockwell International Corporation as an unpublished work.  This work was created 1989-1992 and contains proprietaryinformation of Rockwell International Corporation.  All rights arereserved.  Disclosure without written authorization is prohibited."))))|#(defmethod enable-frame :after ((frame graph-editor))  (let ((win (get-frame-pane frame 'messages)))    (terpri win)    (write-string "Copyright by Rockwell International Corporation as an unpublished work.  This work was created 1989-1992 and contains proprietaryinformation of Rockwell International Corporation.  All rights arereserved.  Disclosure without written authorization is prohibited."	    win)    ));;;----------------;;;   ooooooo          GRAPH-EDITOR ACCESS FUNCTIONS;;;----------------;;; uniform access to some commonly used parts of graph-editor;;; an alternate version of get-graph-editor is defined in;;; node-editor.lisp, for access from the node-editor code(defmethod graph-editor ((frame t)) nil)(defmethod graph-editor ((frame graph-editor))  (values frame));;(defmethod get-graph-editor ();;  );;; mcl couldn't handle defmethods without a required argument(defun get-graph-editor ()  (when (boundp '*application-frame*)    (graph-editor *application-frame*)))(defun display (&key (frame (get-graph-editor)))  "return the stream associated with the main display window"  (get-frame-pane frame 'display))(defun display-xform (&key (frame (get-graph-editor)))  "return the transformation currently in use for the display;   all invocations of draw-self should use this transform"  (slot-value frame 'transform))(defmethod get-selection ((frame graph-editor))  (with-slots (node-list link-list) frame    (or (dolist (n node-list)	  (if (selected-p n) (return n)))	(dolist (n link-list)	  (if (selected-p n) (return n))))));;;-----------------(defun messages (&key (frame (get-graph-editor)))  "return the stream associated with the main messages window"  (get-frame-pane frame 'messages));;; general error-reporting macro(defun beep-message (&rest arg-list)  (beep)  (fresh-line (messages))  (apply #'format (messages) arg-list))(defun show-message (&rest arg-list)  (fresh-line (messages))  (apply #'format (cons (messages) arg-list)));;;-----------------(defun solution-generation (&key (frame (get-graph-editor)))  (slot-value frame 'solution-generation))(defun structure-changed (&key (frame (get-graph-editor)))  (incf (slot-value frame 'structure-generation)));;;----------------;;; these functions check for the existence of frame, because;;; they get called by some of the graph-solution methods,;;; which can work outside of a graph-editor.(defun structure-generation (&key (frame (get-graph-editor)))  (if frame      (slot-value frame 'structure-generation)      -1))(defun get-graph-structure (name &key (frame (get-graph-editor)))  (when frame    (gethash name (slot-value frame 'graph-structures))))(defun put-graph-structure (name new-val &key (frame (get-graph-editor)))  (when frame    (setf (gethash name (slot-value frame 'graph-structures)) new-val)));;;----------------(defmethod get-parents-of-node ((node graph-node) 				&key (frame (get-graph-editor)))  (with-slots (link-list) frame    (mapcar #'from-node      (remove-if-not #'(lambda (l) (is-link-to l node))		     link-list))))(defmethod get-children-of-node ((node graph-node)				 &key (frame (get-graph-editor)))  (with-slots (link-list) frame    (mapcar #'to-node	    (remove-if-not #'(lambda (l) (is-link-from l node))			   link-list))))(defmethod get-children-links-of-node ((node graph-node)				 &key (frame (get-graph-editor)))  (with-slots (link-list) frame    (remove-if-not #'(lambda (l) (is-link-from l node))			   link-list)))(defmethod get-parents-links-of-node ((node graph-node) 				      &key (frame (get-graph-editor)))  (with-slots (link-list) frame    (remove-if-not #'(lambda (l) (is-link-to l node))		   link-list)));;;----------------(defmethod find-node-named ((name symbol)			    &key (frame (get-graph-editor)))  "return ideal-edit node named 'name', if it exists"  (with-slots (node-list) frame    (car (member-if #'(lambda (n) (eq (slot-value n 'name) name))	       node-list))));;;----------------(defun show-mode (&optional (frame (get-graph-editor))			    (stream (get-frame-pane frame 'mode))			    &rest stuff)  (declare (ignore stuff))  (with-slots (add-node-type filename solve-name) frame    (with-text-style	(stream (make-text-style :sans-serif nil nil))      (format stream "   Add Type:  ~a" add-node-type)      (format stream "   Algorithm: ~a" 	      (if solve-name solve-name "---"))      (format stream "   File:  ~a"	      (if filename (pathname-name filename) "---")	      );;      (if filename (enough-namestring filename) "---")      )));;;----------------;;; intended for accepting things with the;;; mouse from the graphic display;;;; returns nil if you click on blank space(define-presentation-type nothing ())(define-presentation-translator blank-to-nil    (blank-area nothing graph-editor)  ()  (values nil))(define-presentation-method presentation-typep    (object (type nothing))  (null object))(defun accept-from-display (type &optional prompt)  (fresh-line (messages))  (accept `(or nothing ,type) :stream (messages) :prompt prompt));;;----------------;;;   ooooooo               SHOWING OPTIONS;;;----------------(defvar *initial-showing-options* nil);;; The showing-options slot of a graph-editor holds a hash;;; table which is initialized from the list above.;;; This hash table is for things like display parameters.;;; Keys into this table are names of the options, which must;;; be symbols, and the values must be showing-option structures,;;; as defined below.  The idea is that this will make it easier;;; to define other graphical goodies in a fairly independent;;; manner -- we'll see if it works...;;;;;; The slots of the showing-option structure have the following;;; meanings:;;;;;;	option-value		-- an arbitrary symbol;;;     next-value              -- lambda (old-value) ==> new-val;;;                                when the user clicks on the entry in the;;;                                menu, what new value is chosen.;;;	change-option		-- lambda (old-value new-value);;;				   a function which does whatever needs;;;				   to be done to set the value.;;;	re-display		-- lambda (current-value);;;				   if the "display" were cleared, this;;;				   does whatever is needed to re-establish;;;				   the current state.;;;(defstruct (showing-option (:conc-name nil))   option-value   next-value   change-option   re-display);;; how to establish a showing option:(defun create-showing-option (name init-val next-value-fn 			      change-option-fn re-display-fn)  (push (cons name (make-showing-option	  	    :option-value init-val		    :next-value next-value-fn		    :change-option change-option-fn		    :re-display re-display-fn))	*initial-showing-options*))(defun make-options-table ()  (let ((table (make-hash-table)))    (mapc #'(lambda (os)	      (setf (gethash (car os) table)		    (copy-showing-option (cdr os))))	  *initial-showing-options*)    (values table)));;; pretty access functions(defun get-showing-option (name &key (frame (get-graph-editor)))  (option-value (gethash name (slot-value frame 'showing-options))))(defun set-showing-option (name new-val &key (frame (get-graph-editor)))  (let* ((option (gethash name (slot-value frame 'showing-options)))	 (old-val (option-value option)))    (setf (option-value option) new-val)    (funcall (change-option option) old-val new-val)))(defun inc-showing-option (name &key (frame (get-graph-editor)))  (let* ((option (gethash name (slot-value frame 'showing-options)))	 (old-val (option-value option))	 (new-val (funcall (next-value option) old-val)))    (setf (option-value option) new-val)    (funcall (change-option option) old-val new-val)))(defun re-display-options (&key (frame (get-graph-editor)))  (maphash #'(lambda (k o) 	       (declare (ignore k))	       (funcall (re-display o) (option-value o)))	   (slot-value frame 'showing-options)))(defun showing-options-menu (&key (frame (get-graph-editor)))  (let ((menu-list nil))    (maphash #'(lambda (name option)		 (setf menu-list		       (cons (cons (format nil "~a / ~a"				           name (option-value option))				   name)			     menu-list)))	     (slot-value frame 'showing-options))    (values menu-list)))