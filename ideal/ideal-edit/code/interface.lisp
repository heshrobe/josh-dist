;;; -*- Mode: LISP; Syntax: Common-Lisp; Base: 10; Package: IDEAL-EDIT -*-(in-package "IDEAL-EDIT");;;;********************************************************;;;;  Copyright (c) 1989, 1992 Rockwell International -- All rights reserved.;;;;  Rockwell International Science Center Palo Alto Lab;;;;********************************************************;;;----------------;;;   ooooooo              VARIABLES & SUCH;;;----------------(export '(run-editor rerun-editor))(setf *default-pathname-defaults* ".")		;;;(defconstant *edit-node-colors* (make-contrasting-inks 3));;(defconstant *edit-path-suffix* (make-pathname :type "gr");;	     "suffix for ideal-edit data files");;; mcl doesn't seem to handle defconstants correctly(defparameter *edit-node-colors* (make-contrasting-inks 3))(defparameter *edit-path-suffix* (make-pathname :type "gr")  "suffix for ideal-edit data files")(defvar *editor* nil)(defvar *diagram-cliques* nil "clique-tree last defined for *diagram*, if any")(defvar *diagram-join-tree* nil "join-tree last defined for *diagram*, if any");;;----------------;;; re-define ideal::ideal-warning to do output to the messages;;; window, when the messages window exists(defun ideal::ideal-warning (&rest arg-list)  (if (get-graph-editor)      (apply #'beep-message arg-list)      (progn (format t "~%IDEAL SYSTEM:~%")	     (apply #'warn arg-list))));;;----------------;;; Clim 'additions';;; Names for mouse clicks(add-gesture-name :left-button :pointer-button :left)	#-mcl(add-gesture-name :middle-button :pointer-button :middle)#+mcl(add-gesture-name :middle-button :pointer-button '(:left :control))#-mcl(add-gesture-name :right-button :pointer-button :right )#+mcl(add-gesture-name :right-button :pointer-button '(:left :meta))(add-gesture-name :left-shift-button :pointer-button '(:left :shift))#-mcl(add-gesture-name :middle-shift-button :pointer-button '(:middle :shift))#+mcl(add-gesture-name :middle-shift-button :pointer-button '(:left :shift :control))#-mcl(add-gesture-name :right-shift-button ::pointer-button '(:right :shift))#+mcl(add-gesture-name :right-shift-button ::pointer-button '(:left :shift :meta));;; a useful macro(defmacro with-unchanged-position ((stream) &body body)  (let ((xsym (gensym "x"))	(ysym (gensym "y")))    `(multiple-value-bind (,xsym ,ysym)      (window-viewport-position ,stream)      ,@body      (window-set-viewport-position ,stream ,xsym ,ysym))));;;----------------;;;   ooooooo                 INTERFACE;;;----------------(defvar clim-user::*clim-root* nil)(defun run-editor (&key (wait nil))  (let ((fcn (if wait #'(lambda (name fcn &rest args)			  (declare (ignore name))			  (apply fcn args))		 #'process-run-function))	process)    (unless clim-user::*clim-root*       (init-x))    (setq *editor* (make-application-frame 'graph-editor					   :pretty-name "IDEAL Editor"					   :parent clim-user::*clim-root*					   :width +fill+					   :height +fill+					   ))    (unwind-protect      (setq process            (funcall fcn                     "Frame Top Level"                     'run-frame-top-level                     *editor*                     ))      (setf ideal:*diagram* (slot-value *editor* 'ideal-diagram))      (values *editor* process)      )))(defun rerun-editor (&optional (editor *editor*))  (setf *editor* editor)  (when *editor*    (process-run-function     "Frame Top Level"     #'run-frame-top-level     *editor*     ))  (setf ideal:*diagram* (slot-value *editor* 'ideal-diagram))  (values *editor*))(defun init-x ()  (setf clim-user::*clim-root* (find-port)))(defun DIAGRAM ()  (slot-value *editor* 'ideal-diagram));;;----------------#+:ALLEGRO(defun dump-editor ()  (excl:dumplisp :name "/tmp/ideal-edit"		 :checkpoint nil));;; for multiprocessing(defun process-run-function (name-or-keywords function &rest args)  (let* ((new-args (copy-list args))		; in case of stack-allocation	 (predicate	  (if args #'(#+genera cl::lambda #-genera lambda () (apply function new-args)) function)))    predicate name-or-keywords    #+ALLEGRO      (funcall #'mp:process-run-function name-or-keywords predicate)    #+GENERA      (funcall #'scl:process-run-function name-or-keywords predicate)    #+LUCID      (flet ((lucid-process-run-function-hack (NAME-OR-KEYWORDS					       &rest FNCT-LIST)	       (let ((FNCT-NAME (first FNCT-LIST))		     (FNCT-ARGS (copy-list (cdr FNCT-LIST))))		 (if (consp NAME-OR-KEYWORDS)		     (apply #'user::make-process			    :function FNCT-NAME			    :args FNCT-ARGS			    NAME-OR-KEYWORDS)		     (user::make-process		      :name NAME-OR-KEYWORDS		      :function FNCT-NAME		      :args FNCT-ARGS)))))	(apply #'lucid-process-run-function-hack	       name-or-keywords function args))      #+MCL      (funcall #'ccl:process-run-function name-or-keywords predicate)      ))