;;; -*- Mode: Lisp; Syntax: ANSI-Common-Lisp; Package: POSTSCRIPT-CLIM; Base: 10; Lowercase: Yes -*-;; $fiHeader: postscript-port.lisp,v 1.14 92/12/17 15:33:11 cer Exp $(in-package :postscript-clim)"Copyright (c) 1990, 1991, 1992 Symbolics, Inc.  All rights reserved."(defmethod postscript-prologue ((medium postscript-medium)				&key scale-factor (orientation :portrait)				     header-comments)  (let ((printer-stream (slot-value medium 'printer-stream))	(port (port medium)))    (format printer-stream "%!PS-Adobe-2.0 EPSF-2.0~%")    (multiple-value-bind (left top right bottom) (postscript-bounding-box-edges (medium-sheet medium))      (write-string "%%BoundingBox: " printer-stream)      (flet ((write-point* (x y)               (ps-optimal-flonize                (+ (* (slot-value port 'page-indent)	              (slot-value port 'device-units-per-inch)) x)                printer-stream)               (write-char #\space printer-stream)               (ps-optimal-flonize                (- (* (if (eq orientation :landscape)                        (slot-value port 'page-width)                        (slot-value port 'page-height))	              (slot-value port 'device-units-per-inch)) y)                printer-stream)               (write-char #\space printer-stream)))      (write-point* left bottom)      (write-point* right top)      (format printer-stream "~%")))    (format printer-stream "%%Creator: CLIM 2.0~%")    (let ((title (getf header-comments :title)))      (when title        (format printer-stream "%%Title: ~A~%" title)))    (let ((for (or (getf header-comments :for) #+Genera zl:user-id)))      (when for        (format printer-stream "%%For: ~A~%" for)))    (multiple-value-bind (second minute hour date month year)	(decode-universal-time (get-universal-time))      (format printer-stream "%%CreationDate: ~D-~A-~D ~2,'0D:~2,'0D:~2,'0D~%"	date (svref #("Jan" "Feb" "Mar" "Apr" "May" "Jun"		      "Jul" "Aug" "Sep" "Oct" "Nov" "Dec") (1- month)) year	hour minute second))    (format printer-stream "%%DocumentFonts: (atend)~%")    (format printer-stream "%%EndComments~%")    (write-string *postscript-prologue* printer-stream)    (ecase orientation      (:portrait        (format printer-stream            "/format-rotation 0 def ~%/format-y-translation 0 def~%"))      (:landscape        (format printer-stream            "/format-rotation -90 def ~%/format-y-translation ~D def~%"           (float (* (slot-value port 'page-height)		    (slot-value port 'device-units-per-inch))))))    (format printer-stream "/format-scale ~D def~%" (float (or scale-factor 1)))    (format printer-stream        "/new-matrix {0 format-y-translation translate		      format-rotation rotate		      format-scale format-scale scale} def	 /new-page {showpage new-matrix} def~%")    (postscript-device-prologue port printer-stream)    (format printer-stream "%%EndProlog~%")    (format printer-stream "~%new-matrix~%")))(defun invoke-with-output-to-postscript-stream (file-stream continuation						&key (device-type 'apple-laser-writer)						     multi-page scale-to-fit						     header-comments (destination :printer)						     (orientation :portrait))  (assert (not (and multi-page scale-to-fit)) (multi-page scale-to-fit)	  "You may not use both ~S and ~S" ':multi-page ':scale-to-fit)  (check-type orientation (member :landscape :portrait))  (check-type destination (member :printer :document :document-inclusion))  (let* ((port (find-port :server-path (list device-type)))	 (stream (make-instance 'postscript-stream		   :multi-page multi-page		   :scale-to-fit scale-to-fit)))    (setf (port stream) port)    (let ((medium (sheet-medium stream)))      (setf (slot-value medium 'printer-stream) file-stream	    (slot-value medium 'orientation) orientation	    (slot-value medium 'destination) destination)      (unwind-protect	  (if scale-to-fit	      (multiple-value-prog1		(with-output-recording-options (stream :record t :draw nil)		  (funcall continuation stream))		(multiple-value-bind (width height) 		    (bounding-rectangle-size (stream-output-history stream))		  (let* ((page-width			   (floor (* (slot-value port 'page-width)				     (slot-value port 'device-units-per-inch))				  *1-pixel=points*))			 (page-height			   (floor (* (slot-value port 'page-height)				     (slot-value port 'device-units-per-inch))				  *1-pixel=points*))			 (scale-factor			   (progn			     (when (eq orientation :landscape)			       (rotatef page-width page-height))			     (if (or (not scale-to-fit)				     (and (< width page-width)					  (< height page-height)))				 1				 (min (/ page-width width)				      (/ page-height height))))))		    (postscript-prologue medium					 :scale-factor scale-factor					 :orientation orientation					 :header-comments header-comments)))		;; Now do the output to the printer, on a single page		(with-output-recording-options (stream :record nil :draw t)		  (stream-replay stream nil))		(postscript-epilogue medium))	      (progn		;; Not scaling to a single page, do the prologue                ;; but only after recording the output so that the bounding box is right		(multiple-value-prog1		  (with-output-recording-options (stream :record t :draw nil)		    (funcall continuation stream))                  (postscript-prologue medium				     :scale-factor 1				     :orientation orientation				     :header-comments header-comments)		  ;; Now do the output to the printer, breaking up the output into		  ;; multiple pages if that was requested		  (with-output-recording-options (stream :record nil :draw t)		    (stream-replay stream nil))		  (postscript-epilogue medium))))	;; Since we can reuse the port later, we have to clobber the FCS	;; so that the port doesn't think we've done an estfont next time	(let* ((font-map (slot-value port 'font-map))	       (nfonts (length font-map)))	  (do ((i 0 (1+ i)))	      ((>= i nfonts))	    (let ((fcs (aref font-map i)))	      (when fcs		(setf (psfck-established fcs) nil)))))))))